# programming-patterns

[July 2016] MVC---
Stands for Model/View/Controller. Is a software architectural pattern for implementing UI. Divides given software application into three parts. Very popular for web applications. Model directly manages the data, logic, rules of application and also stores retrieved data for view. View is an informational output of Model such as a chart or diagram to user. Controller acccepts user input and manipulates the Model state (ex. edit document) or View (ex. scroll down in document).

[August 2016] Value Object---
A small object that represents a simple identity (ex. date range, money, name) whose equality is not based on identity (equal based on values of their fields, not being the same object reference). Value objects should be immutable, since two value objects created equal should remain equal. Value objects may also be immutable to prevent them from being put in an invalid state. In summary, objects are mutable while value objects are immutable, and objects are referenced (obj1=obj2 assings obj1 a reference to obj2) while value objects are copied by value (valobj1=valobj2 makes a copy of the attributes of valobj2 to valobj1). Native support in C#, emulated in Java by making object immutable (since if state of object does not change, passing reference is semantically equivalent to copying value object).

[July 2016] Business Delegate---
Is a programming pattern used in J2EE for multi-tiered, distributed systems. Deals with the issue of presentation-tier clients (devices, web clients, etc.) directly interfacing with business service APIs. Direct interfacing causes client/presentation-tier components to become vulnerable to changes in business services. Direct interfacing hurts network performance when presentation-tier makes too many calls to business service API over network. Hiding implementation details of the business service such as lookup and access minimizes coupling (ex. Client requests BusinessDelegate to provide access to underlying business service -> BusinessDelegate uses a LookupService to locate and create the required BusinessService component -> The BusinessService then can be used to invoke business methods on behalf of the Client when requested via BusinessDelegate). The BusinessDelegate can obtain String versions of the handles for the BusinessService and cache it to later use to reconnect to the BusinessService being used when the handle was created, avoiding new lookups. Note that Handle objects are implemented by the container provider and may not be portable across containers from different vendors. Clients may need to implement caching mechanisms for business service information in order to achieve this. Overall, the benefits are to reduce coupling and improve manageability and shield clients from knowledge of implementation, exception handling, failure recovery, and thread synchronization specifics. The downsides are that it introduces an additional layer between the Client and the business service, and may hide remoteness of the service to the Client developers if the Business Delegate appears to be a local one. The developer may tend to make numerous method invocations to perform a single task which increases network traffic.

[August 2016] Session Facade---
In multi-tiered J2EE platforms, tight coupling between clients and business objects ("enterprise bean" server-side remote bjects that encapsulate business logic/data such as (1) transient/non-persistent "session bean" objects that represent clients and allow them to invoke its methods to communicate/make requests on the J2EE enterprise server & (2) persistent "entity bean" objects that represent a view of a business entity object in a persistent storage mechanism such as a relational database, object database, legacy application, file, etc. for multiple clients, and and other arbitrary objects that provide services/data) may lead to direct dependence. Direct dependence means the client must implement complex interactions for business object lookups and creations,  must manage the relationships between the participating business objects, and understand the responsibility of transaction demarcation. As client requirements increase, the complexity of interaction increases and the client must grow larger and more complex. This increases rigidity and makes it difficult to implement changes. In addition, too many direct method invocations between client and server objects leads to network problems since enterprise beans are remote objects, and lack of uniform client access strategy can expose business objects to misuse. A sesion facade abstracts the underlying business object interactions and provides a service layer that exposes only the required interfaces, hiding the complexity from the client. It also manages the interactions between the business data and business service objects in the workflow and encapsulates the business logic associated wtih the requirements. As such, the session bean (representing the session facade) manages the relationships between business objects and their life cycle via appropriate creation, locating/look-up, modification, and deletion as required by the workflow. In more complex applications, the session facade may delegate all or parts of this management to a separate object (such as a service locator object). Note that mapping every use case to a session facade results in too many of them and defeats the purpose of having fewer coarse-grained session beans - instead look to consolidate them in a logical partitioning (ex. in banking application, grouping interactions related to managing an account like create new account, change account info, view account info, etc. into a single facade - in this case the facade becomes a highly coarse-grained controller with high level methods to facilitate each interaction such as createNewAccount, changeAccount, getAccount). Overall, the advantages are to introduce a business-tier controller layer, expose a uniform interface, reduce coupling, increase manageability, improve performance, reduce fine-grained methods, provide coarse-grained access, centralize security management, centralize transaction control, and expose fewer remote interfaces to clients.

[August 2016] Composite Entity---
Clients in J2EE such as applications, JavaServer Pages (JSP) pages, servlets, and Javabeans components access entity beans representing distributed persistent business objects through their remote interfaces, resulting in every client invocation potentially impacting performance by routing through network stubs and skeletons even if the client and enterprise bean are in the same JVM, OS, or machine. When these entity beans are fine-grained objects, clients tend to evoke more individual entity bean methods resulting in high network overhead. As such entity beans should represent coarse-grained business objects with more complex behavior than simply getting and setting field values, and have dependent objects with no real domain meaning when not associated with its coarse-grained parent. When direct mapping of the object model to an EJB model (entity beans) occurs, fine-grained entity beans tend to be created. Many fine-grained entity beans require a large number of classes to define their home and remote interfaces, implementation, and primary key. In addition, the container may also generate classes to support the entity bean implementation. This all results in more code to develop and maintain. Lastly, when entity beans are fine-grained, each bean instance usually represents a single row in a database - this is improper design since entity beans are more suitable for coarse-grained components, and modeling single rows cause clients to become dependent on database schema and have to manage schema changes. Relationships between fine and coarse-grained entity beans are also an issue - for example, an entity bean might contain or hold a remote reference to another entity bean, increasing code flexibility and requiring that the entity bean change if any of its relationships cahnges. There is also no guarantee as to the validity of the entity bean references to other entity beans over time, requiring high overhead of reference checking validity. A solution is to use composite entity representing a graph of objects to model, represent, and manage a set of interrelated persistent objects rather than representing them as individual fine-grained entity beans. It does this by representing a coarse-grained object (a persistent object which is self-sufficient, has its own lifecycle, manages its relationships with other objects, and has references to one or more other ojects) as well as its dependent objects (having lifecycle tightly coupled to the life cycle of the coarse-grained object, and may only be indirectly accessed through its parent coarse-grained object) as a single aggregated entity bean. Without composite entity, the coarse-grained and dependent objects tend to be viewed as separate entity beans. The advantages of using composite entity is therefore elimination of inter-entity relationships, improving manageability of the number of entity beans, improving network performance by reducing fine-grained communications and overhead of loading and storing dependent objects, increases object granularity, and facilitates composite transfer object creation to reduce the chattiness of communication by returning all data in one remote call.

[August 2016] Service Locator---
Enterprise JavaBeans (EJB) and Java Message Service (JMS) are service components of J2EE which provide business services and persistence capabilities. However, to interact with these components the client must either locate them with a lookup operation or create a new component (ex. EJB client must locate the enterprise bean's home object to find an object or create or remove enterprise beans, and JMS client must first locate the JMS connection factory to obtain a JMS connection or JMS session). All J2EE application clients must use the JNDI common facility API to look up and create EJB and JMS components by creating an initial context object that holds the component name to object bindings, which remains valid while the client session is valid. Thus JNDI service code appears multiple times across these clients, resulting in an unncessary duplication of code. Creating a JNDI initial context object and performing a lookup on an EJB home object utilizes significant resources and repeated requests by multiple clients can impact application performance. In addition, the context factory to use for initial JNDI context creation is provided by the service provider vendor and is vendor-dependent, and also dependent on the type of object being looked up and whether it is for JMS or EJB. A service locator object can be used to abstract all JNDI usage and hide the complexities of initial context creation, EJB home object lookup, and EJB object re-creation. Multiple clients can reuse the service locator to reduce code complexity, provide a single point of control, and improve performance by providing a caching facility.

Data Access Object---
